{
  
    
        "post0": {
            "title": "Android Animations With React Native (Part 1)!",
            "content": "Overview . This lecture would be a series of we trying to reproduce some Android system applications animations using React Native, the source code for upcoming lectures can be found here ahead of time. . I would also be updating this section in the future as other parts of the series are made available. . For reference, this is what we would be building: . . Setting Up The Project . We would be using expo to boostrap our project . Bootstrapping With Expo . You can read the docs on how to install and set up expo. . Now, let&#39;s create the project using expo, run the following command in the terminal: . expo init react-native-animations . Then select managed typescript configuration, wait for it to set up the project. . Installing The Dependencies . We would be needing React Native Reanimated, React Native Gesture Handler and React Native SVG to build the animations, handle gestures and draw paths respectively. We can install them using the following command: . With npm: . npm install --save react-native-reanimated react-native-gesture-handler react-native-svg . With yarn: . yarn add react-native-reanimated react-native-gesture-handler react-native-svg . Finally for the setup, we would have to add Reanimated plugin to the babelconfig.js file like so: . module.exports = { ... plugins: [ &quot;react-native-reanimated/plugin&quot;, ], ... }; . Building The Project . Let us create a file called IncomingCall.tsx and add the following code to build the view: . import React from &quot;react&quot;; import { StyleSheet, Text, View } from &quot;react-native&quot;; import { useSafeAreaInsets } from &quot;react-native-safe-area-context&quot;; function IncomingCall() { const edges = useSafeAreaInsets(); return ( &lt;View style={[styles.container, { paddingTop: edges.top }]}&gt; &lt;View&gt; &lt;Text style={styles.callingText}&gt;Call from&lt;/Text&gt; &lt;Text style={styles.titleText}&gt;Tech Support NG&lt;/Text&gt; &lt;Text style={styles.callingText}&gt;Mobile +234 00 000 000&lt;/Text&gt; &lt;/View&gt; &lt;View style={styles.actionsContainer}&gt; &lt;Text style={styles.acceptText}&gt;Swipe up to answer...&lt;/Text&gt; &lt;Text style={styles.iconContainer}&gt;📞&lt;/Text&gt; &lt;Text style={styles.declineText}&gt;Swipe down to decline...&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ acceptText: { color: &quot;#7B7C81&quot;, fontStyle: &quot;italic&quot;, marginBottom: 12, }, actionsContainer: { alignItems: &quot;center&quot;, paddingBottom: 40, }, callingText: { color: &quot;#fff&quot;, fontSize: 20, marginBottom: 8, textAlign: &quot;center&quot;, }, container: { alignItems: &quot;center&quot;, backgroundColor: &quot;#222328&quot;, flex: 1, justifyContent: &quot;space-between&quot;, padding: 8, }, declineText: { color: &quot;#7B7C81&quot;, fontStyle: &quot;italic&quot;, marginTop: 12, }, iconContainer: { color: &quot;#000&quot; }, titleText: { color: &quot;#fff&quot;, fontSize: 36, fontWeight: &quot;800&quot;, marginBottom: 8, textAlign: &quot;center&quot;, }, }); export default IncomingCall; . We should get the following on our screen: . . Dont worry about the phone icon emoji, it is just a placeholder, we&#39;d be building that later on. . Mount Animation . Now that we have a skeleton of the view, let&#39;s start animating! . From our reference, when the screen mounts the Swipe up to answer... text, Swipe down to decline... text and the Icon translate from the bottom of the screen on the y axis. Their opacity also fades in as they appear on the screen. We can use the parent view holding these elements to do this translation. We&#39;d update the view to an animated one and define two shared values, one for translation and the other for opacity. . ... import Animated, { useSharedValue } from &quot;react-native-reanimated&quot;; ... function IncomingCall() { ... const gestureOpacity = useSharedValue(0); const gestureTranslate = useSharedValue(100); ... return ( ... &lt;Animated.View style={styles.actionsContainer}&gt; &lt;Text style={styles.acceptText}&gt;Swipe up to answer...&lt;/Text&gt; &lt;Text style={styles.iconContainer}&gt;📞&lt;/Text&gt; &lt;Text style={styles.declineText}&gt;Swipe down to decline...&lt;/Text&gt; &lt;/Animated.View&gt; ... ) } ... . We are initializing our translation shared value to 100, because we want to start the animation from 100 pixels close the bottom of the screen to the original position according to it&#39;s layout which would be 0. Also for the opacity we are moving from 0 to 1. . ... import Animated, { useAnimatedStyle, useSharedValue, withTiming } from &quot;react-native-reanimated&quot;; ... function IncomingCall() { ... React.useEffect(() =&gt; { gestureTranslate.value = withTiming(0, { duration: 1000, easing: Easing.elastic(1) }); gestureOpacity.value = withTiming(1, { duration: 1000 }); }, []); ... const gestureContainerStyle = useAnimatedStyle(() =&gt; ({ opacity: gestureOpacity.value, transform: [{ translateY: gestureTranslate.value }], })); ... return ( ... &lt;Animated.View style={[styles.actionsContainer, gestureContainerStyle]}&gt; &lt;Text style={styles.acceptText}&gt;Swipe up to answer...&lt;/Text&gt; &lt;Text style={styles.iconContainer}&gt;📞&lt;/Text&gt; &lt;Text style={styles.declineText}&gt;Swipe down to decline...&lt;/Text&gt; &lt;/Animated.View&gt; ... ) } ... . We also added easing to the animation to give us an elastic effect. . This should result in the following: . . Putting Together The Loop Animation . Next, we notice from our reference that after the mount animation, we get a loop animation that translates the Swipe up to answer... and the Icon from their layout positions to some pixels up and then back to their original position. We also get the Swipe down to decline... text to fade in and out as this is going on. . We can wrap our Swipe up to answer... text and Icon in an Animated.View which we would apply the styles to translate back and forth on and then we can interpolate from this to get the opacity of the text Swipe down to decline... to fade in and out. . ... function IncomingCall() { ... const repeatTranslate = useSharedValue(0); ... const doRepeat = () =&gt; { &quot;worklet&quot;; repeatTranslate.value = withRepeat( withTiming(-50, { duration: 1500, }), -1, true, ); }; ... const declineOpacity = useAnimatedStyle(() =&gt; { const opacity = interpolate( repeatTranslate.value, [-50, 0], [0, 1], Extrapolate.CLAMP, ); return { opacity }; }); ... React.useEffect(() =&gt; { gestureTranslate.value = withTiming( 0, { duration: 1000, easing: Easing.elastic(1) }, (isFinished) =&gt; { if (isFinished) { doRepeat(); } }, ); gestureOpacity.value = withTiming(1, { duration: 1000 }); }, []); ... return ( ... &lt;Animated.View style={[styles.actionsContainer, gestureContainerStyle]}&gt; &lt;Animated.View style={[styles.repeatContainer, repeatTranslateStyle]}&gt; &lt;Text style={styles.acceptText}&gt;Swipe up to answer...&lt;/Text&gt; &lt;Text style=&gt;📞&lt;/Text&gt; &lt;/Animated.View&gt; &lt;Animated.Text style={[styles.declineText, declineOpacity]}&gt; Swipe down to decline... &lt;/Animated.Text&gt; &lt;/Animated.View&gt; ... ) } ... const styles = StyleSheet.create({ ... repeatContainer: { alignItems: &quot;center&quot;, }, ... }) . From the snippet above, we create a doRepeat function which is our own custom worklet that would be called when the mount animation is finished. Within this function we have a withRepeat function which takes other animation functions like withTiming and repeats it a number of times, we are passing -1 as our number of repitition which means it should create an infinite loop, also we are passing true as our third argument which translates our shared value (repeatTranslate) from 0 to -50, then back to 0. Finally we interpolate on these values to get the opacity of the decline text to fade in and out. We add Extrapolate.CLAMP to the interpolation to make sure that the opacity never goes below 0 or above 1. . This should result to this on our screen: . . Handling Swipes . The next thing to do would be to handle the user swipe gestures to either accept the call or decline it. We would be using the PanGestureHandler component to handle this. We have to wrap the components we want to be swipeable with the PanGestureHandler component. . ... import { PanGestureHandler } from &quot;react-native-gesture-handler&quot;; ... function IncomingCall() { return ( ... &lt;PanGestureHandler activeOffsetY={[0, 0]}&gt; &lt;Animated.View style={[styles.repeatContainer, repeatTranslateStyle]}&gt; &lt;Text style={styles.acceptText}&gt;Swipe up to answer...&lt;/Text&gt; &lt;Text style=&gt;📞&lt;/Text&gt; &lt;/Animated.View&gt; &lt;/PanGestureHandler&gt; &lt;Animated.Text style={[styles.declineText, declineOpacity]}&gt; Swipe down to decline... &lt;/Animated.Text&gt; ... ) . We wouldn&#39;t be able to swipe just yet because we haven&#39;t handled the swipe gesture events yet. That&#39;s what we will be doing next. . Important: The first child of a PanGestureHandler component must be an Animated.View or else it would not work! . Handling Swipe Events . To handle the swipe events we would be using the PanGestureHandler component&#39;s onGestureEvent prop, and also define the events using the useAnimatedGestureHandler hook from the react-native-reanimated package. We&#39;d create a shared value where we would store the gesture translation, which we can then use in our style for the component we want to be swipeable. . ... import { PanGestureHandlerGestureEvent } from &quot;react-native-gesture-handler&quot;; import { useAnimatedGestureHandler } from &quot;react-native-reanimated&quot;; ... type Context = { translateY: number; }; ... function IncomingCall() { ... const swipe = useSharedValue(0); ... const gestureHandler = useAnimatedGestureHandler&lt; PanGestureHandlerGestureEvent, Context &gt; ({ onActive:({ translationY }, context) =&gt; { ... swipe.value = translationY + context.translateY; }, onFinish: () =&gt; { swipe.value = withTiming(0, { easing: Easing.inOut(Easing.linear) }); }, onStart: (_, context) =&gt; { context.translateY = swipe.value; }, }); ... const swipeStyle = useAnimatedStyle(() =&gt; ({ transform: [{ translateY: swipe.value }], })); ... return ( ... &lt;PanGestureHandler activeOffsetY={[0, 0]} onGestureEvent={gestureHandler}&gt; &lt;Animated.View style={[styles.repeatContainer, repeatTranslateStyle]}&gt; &lt;Text style={styles.acceptText}&gt;Swipe up to answer...&lt;/Text&gt; &lt;Animated.View style={swipeStyle}&gt; &lt;Text style=&gt;📞&lt;/Text&gt; &lt;/Animated.View&gt; &lt;/Animated.View&gt; &lt;/PanGestureHandler&gt; ... ) } ... . We wrap our icon placeholder with an Animated.View which we would apply the swipe styles to. This makes the icon move with the swipe gesture based on the translationY value we get from the PanGestureHandler. . The onActive callback is used to get the current value of our swipe translationY on the screen and this is stored in the swipe shared value. The onFinish callback is used to reset the swipe shared value to 0 after the gesture is finished. The onStart callback is used to store the swipe value in a context object, so that we do not start from 0 again when we start a new gesture. . We should get this on our screen: . . However we quickly notice that we can swipe our icon to the very top and very bottom of our screens, this is not what we intended, so we write a clamp worklet function to handle this by limiting the value we assign to the swipe shared value to be between the minimum and maximum we specify. . ... function clamp(number: number, min: number, max: number) { &quot;worklet&quot;; return Math.min(Math.max(number, min), max); } ... const maxClamp = 60; const minClamp = -80; ... function IncomingCall() { ... const gestureHandler = useAnimatedGestureHandler&lt; PanGestureHandlerGestureEvent, Context &gt; ({ onActive:({ translationY }, context) =&gt; { ... const current = translationY + context.translateY; swipe.value = clamp(current, minClamp, maxClamp); }, ... }); ... } ... . Now our swipe shared value will be clamped between the -80 and 60 as specified above. This results in: . . Handling Loop Animation On Swipe . From what we have so far above, you&#39;d notice that when we start swiping, our loop animation is still repeating, this is because we are using the withRepeat function to repeat the animation. The preffered behaviour would be to stop the animation altogether when the user starts swiping and then start it again when the user stops swiping. We can do this by setting the repeatTranslate shared value to 0 in the onActive callback and then calling the doRepeat worklet function in the onFinish callback. . ... const gestureHandler = useAnimatedGestureHandler&lt; PanGestureHandlerGestureEvent, Context &gt; ({ onActive:({ translationY }, context) =&gt; { ... repeatTranslate.value = 0; const current = translationY + context.translateY; swipe.value = clamp(current, minClamp, maxClamp); }, onFinish: () =&gt; { swipe.value = withTiming(0, { easing: Easing.inOut(Easing.linear) }); doRepeat(); }, ... }) . We should get this on our screens: . . Handling Opacity Of Texts When Swiping . According to the reference, when we start swiping, both the accept text and decline text would fade out. And when the swipe gesture is finished, both the accept text and decline text would fade in. We can achieve this in two ways, either interpolating on the swipe shared value or creating a shared value textOpacity which we can the animate to 0 in the onStart callback, and animate to 1 in the onFinish callback. Both would give similar results, but I prefer the latter. . ... function IncomingCall() { ... const textOpacity = useSharedValue(1); ... const acceptOpacity = useAnimatedStyle(() =&gt; ({ opacity: textOpacity.value, })); const declineOpacity = useAnimatedStyle(() =&gt; { const opacity = interpolate( repeatTranslate.value, [-50, 0], [0, 1], Extrapolate.CLAMP, ); return { opacity: repeatTranslate.value === 0 ? textOpacity.value : opacity, }; }); ... const gestureHandler = useAnimatedGestureHandler&lt; PanGestureHandlerGestureEvent, Context &gt; ({ onActive:({ translationY }, context) =&gt; { ... textOpacity.value = withTiming(0); }, onFinish: () =&gt; { ... textOpacity.value = withTiming(1); ... }, ... }); ... return ( ... &lt;Animated.Text style={[styles.acceptText, acceptOpacity]}&gt; Swipe up to answer... &lt;/Animated.Text&gt; .... &lt;Animated.Text style={[styles.declineText, declineOpacity]}&gt; Swipe down to decline... &lt;/Animated.Text&gt; ... ) } ... . We modified declineOpacity style and set the opacity conditionally based on the repeatTranslate shared value. We also added acceptOpacity style for the accept text. . This should result in: . . Building Our Icon Animation . Next thing to do is to remove our icon placeholder and replace it with our animated icon. We are going to be using SVG&#39;s to build our icon, I grabbed one of the icons from SVG Repo and converted it to a React Native component using SVGR. Here is the converted icon component in a separate file &quot;PhoneIcon.tsx&quot;: . import * as React from &quot;react&quot;; import Svg, { Path, SvgProps } from &quot;react-native-svg&quot;; function PhoneIcon(props: SvgProps) { return ( &lt;Svg fill=&quot;none&quot; height={24} width={24} {...props}&gt; &lt;Path d=&quot;M3.51 2l3.64.132A1.961 1.961 0 018.89 3.37l1.077 2.662c.25.62.183 1.326-.18 1.884l-1.379 2.121c.817 1.173 3.037 3.919 5.388 5.526l1.752-1.079a1.917 1.917 0 011.483-.226l3.485.894c.927.237 1.551 1.126 1.478 2.103l-.224 2.983c-.078 1.047-.935 1.869-1.952 1.75C6.392 20.429-1.481 2 3.511 2z&quot; stroke=&quot;#0f0&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} /&gt; &lt;/Svg&gt; ); } export default PhoneIcon; . Now we can import it and use it in our screen to replace the placeholder icon: . return ( ... &lt;Animated.View style={[styles.iconContainer, swipeStyle]}&gt; &lt;PhoneIcon /&gt; &lt;/Animated.View&gt; ... ) ... const styles = StyleSheet.create({ ... iconContainer: { alignItems: &quot;center&quot;, backgroundColor: &quot;#3A3B40&quot;, borderRadius: 40, height: 80, justifyContent: &quot;center&quot;, width: 80, }, ... }); ... . We should get this on our screen: . . Animating Our SVG Icon . We would like to animate the stroke color and also rotate the icon based on the swipe gesture, we&#39;d have to turn our Path to an Animated one and also wrap the icon in an Animated.View. to apply the rotation style. . ... import { StyleProp, ViewStyle } from &quot;react-native&quot;; import Animated from &quot;react-native-reanimated&quot;; import Svg, { Path, PathProps, SvgProps } from &quot;react-native-svg&quot;; const AnimatedPath = Animated.createAnimatedComponent(Path); interface IconProps extends SvgProps { animatedProps?: Partial&lt;Animated.AnimateProps&lt;PathProps&gt;&gt; | undefined; rotationStyle?: StyleProp&lt;Animated.AnimateStyle&lt;StyleProp&lt;ViewStyle&gt;&gt;&gt;; } function PhoneIcon(props: IconProps) { return ( &lt;Animated.View style={props.rotationStyle}&gt; &lt;Svg fill=&quot;none&quot; height={24} width={24} {...props}&gt; &lt;AnimatedPath animatedProps={props.animatedProps} d=&quot;M3.51 2l3.64.132A1.961 1.961 0 018.89 3.37l1.077 2.662c.25.62.183 1.326-.18 1.884l-1.379 2.121c.817 1.173 3.037 3.919 5.388 5.526l1.752-1.079a1.917 1.917 0 011.483-.226l3.485.894c.927.237 1.551 1.126 1.478 2.103l-.224 2.983c-.078 1.047-.935 1.869-1.952 1.75C6.392 20.429-1.481 2 3.511 2z&quot; strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} /&gt; &lt;/Svg&gt; &lt;/Animated.View&gt; ); } . . Note: You might get an error message relating to animatedProps, do not panic yet we would fix it soon . Let us define our animatedProps and rotationStyle: . ... import { ... Extrapolate, interpolate, interpolateColor, ... } from &quot;react-native-reanimated&quot;; import { PathProps } from &quot;react-native-svg&quot;; ... function IncomingCall() { ... const iconProps = useAnimatedProps&lt;PathProps&gt;(() =&gt; { const color = interpolateColor( swipe.value, [-50, 0, 50], [&quot;#ffffff&quot;, &quot;#00ff00&quot;, &quot;#ffffff&quot;], ); return { stroke: color, }; }); const rotationStyle = useAnimatedStyle(() =&gt; { const rotation = interpolate( swipe.value, [10, 40], [0, 135], Extrapolate.CLAMP, ); return { transform: [{ rotate: `${rotation}deg` }], }; }); return ( ... &lt;Animated.View style={[styles.iconContainer, swipeStyle]}&gt; &lt;PhoneIcon animatedProps={iconProps} rotationStyle={rotationStyle} /&gt; &lt;/Animated.View&gt; ... ); } ... . From the snippet above we are interpolating on the swipe value to get the color and rotation. To interpolate colors we need to use the interpolateColor function rather than the regular interpolate function. . We also need to animate the icon container&#39;s background color based on the swipe gesture. We just need to add a backgroundColor property to our swipeStyle and then use the interpolateColor function to achieve the desired result based on the swipe gesture. . ... function IncomingCall() { .... const swipeStyle = useAnimatedStyle(() =&gt; { const backgroundColor = interpolateColor( swipe.value, [-100, 0, 50], [&quot;#00ff00&quot;, &quot;#3A3B40&quot;, &quot;#ff0000&quot;], ); return { backgroundColor, transform: [{ translateY: swipe.value }], }; }); ... return ( ... &lt;Animated.View style={[styles.iconContainer, swipeStyle]}&gt; &lt;PhoneIcon animatedProps={iconProps} rotationStyle={rotationStyle} /&gt; &lt;/Animated.View&gt; ... ) } ... . This should give us the following result: . Heading Animation . Next, we would also like to animate the heading container, which houses the Call from text, the Mobile +... text and their name (if saved). . We can just convert the container to an animated one and then interpolate on the swipe shared value to get some transform properties, we are interested in the scale, translateY and opacity properties. . ... function IncomingCall() { .... const headingStyle = useAnimatedStyle(() =&gt; { const opacity = interpolate( swipe.value, [minClamp, 0, maxClamp], [0, 1, 0], Extrapolate.CLAMP, ); const scale = interpolate( swipe.value, [minClamp, 0, maxClamp], [0.7, 1, 0.7], Extrapolate.CLAMP, ); const translateY = interpolate( swipe.value, [minClamp, 0, maxClamp], [200, 0, 200], Extrapolate.CLAMP, ); return { opacity, transform: [{ scale }, { translateY }], }; }); ... return ( .... &lt;Animated.View style={headingStyle}&gt; &lt;Text style={styles.callingText}&gt;Call from&lt;/Text&gt; &lt;Text style={styles.titleText}&gt;Tech Support NG&lt;/Text&gt; &lt;Text style={styles.callingText}&gt;Mobile +234 00 000 000&lt;/Text&gt; &lt;/Animated.View&gt; ... ); } ... . Lastly, we might want to define actions to do when we reach the threshold for accept or rejecting / declining the call. For now we can just log to the console, this can be defined in the onFinish callback. . ... const gestureHandler = useAnimatedGestureHandler&lt; PanGestureHandlerGestureEvent, Context &gt; ({ onFinish:() =&gt; { ... if (swipe.value &lt;= minClamp) { console.log(&quot;Accepting call&quot;); } else if (swipe.value &gt;= maxClamp) { console.log(&quot;Rejecting call&quot;); } ... }, }); ... . Bonus . The phone icon vibrates as it is ringing. Let us declare a shared value vibration, and react to the repeatTranslate shared value, so we can play the animation at a certain point in the repeatTranslate&#39;s translation cycle. . ... import { ... useAnimatedReaction, withSequence, ... } from &quot;react-native-reanimated&quot; ... function IncomingCall() { ... const vibration = useSharedValue(0); ... useAnimatedReaction( () =&gt; repeatTranslate.value, (prep) =&gt; { if (prep === -50) { vibration.value = withSequence( withTiming(-8, { duration: 25 }), withRepeat(withTiming(8, { duration: 50 }), 12, true), withTiming(0, { duration: 25 }), ); } }, ); ... const rotationStyle = useAnimatedStyle(() =&gt; { const rotation = interpolate( swipe.value, [10, 40], [0, 135], Extrapolate.CLAMP, ); return { transform: [ { rotate: `${ repeatTranslate.value === 0 &amp;&amp; swipe.value &gt;= 10 ? rotation : vibration.value }deg`, }, ], }; }); ... } ... . So we effectively modified our rotation style and set the rotate transform property dynamically based on repeatTranslate and swipe values. . Our final result should look like this: . . Refactor, Refactor, Refactor... . Just as a bonus tip, we can refactor our code to make it more readable and maintainable using custom hooks and also moving some of our jsx into custom components. I wouldn&#39;t be touching on the latter, rather I would just provide a snippet on the custom hook part, you can find the refactored code in the GitHub repository. . I have moved all the logic for animations into a custom hook called useIncomingCallAnimation. This hook takes two arguments, a callback for the accept action, and a callback for the reject action, then it returns all our animated styles and props, and gesture handler just as we have used them above. . Using this hook in IncomingCall.tsx component, we can now write the following: . ... function IncomingCall() { ... const { acceptOpacity, declineOpacity, gestureContainerStyle, gestureHandler, headingStyle, iconProps, repeatTranslateStyle, rotationStyle, swipeStyle, } = useIncomingCallAnimation( () =&gt; console.log(&quot;Accepting call&quot;), () =&gt; console.log(&quot;Rejecting call&quot;), ); ... . Click here to checkout the refactored code for the custom hook. .",
            "url": "https://balogunofafrica.github.io/fittedlearner/react%20native/reanimated/material%20you/android/2021/12/02/android-incoming-call-animation.html",
            "relUrl": "/react%20native/reanimated/material%20you/android/2021/12/02/android-incoming-call-animation.html",
            "date": " • Dec 2, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Hello World!",
            "content": "This is just a hello world blog post. My journey with Mobile Development and Machine Learning starts from the second post. . I am excited to document what I learn and think here 🙂. . Come journey with me. . .",
            "url": "https://balogunofafrica.github.io/fittedlearner/first%20blog/hello/2021/06/15/hello-blog.html",
            "relUrl": "/first%20blog/hello/2021/06/15/hello-blog.html",
            "date": " • Jun 15, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://balogunofafrica.github.io/fittedlearner/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://balogunofafrica.github.io/fittedlearner/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}